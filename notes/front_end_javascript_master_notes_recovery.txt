*************************************************************************
  front_end_javascript_master_notes
*************************************************************************

  // objects and function scope
*objects and methods ( this )
*factory functions
*object oriented programing ( key points )
*function contexts and objects
*global object
*Implicit function execution context
*hard binding functions with contexts
*dealing with context loss (3 parts)
*gentle introduction of keyword 'this' blogpost notes
  // closures and function scope
*higher order functions
*closures and private data

  missing after lost backup
    Closures and Private Data	
    Objects and Closures	
    Garbage Collection	
    How Closures Affect Garbage Collection	
    Partial Function Application	
    Immediately Invoked Function Expressions	
    Creating a Private Scope with an IIFE	
  
  // The DOM	
*A Hierarchy of Nodes	
*Node Properties	
*Determining the Type of a Node	
*traversing Nodes
*element attributes
*selecting elements
*creating adding and moving dom nodes
  // event-driven and asynchronous programing
*synchronous and asynchronous
*user interfaces and events
*event handlers / listeners
*event capturing and bubbling (event delegation)

*************************************************************************
*objects and methods ( this )

  methods   => functions with a receiver
  functions => no reciever

  what is the difference between function invocation and method invocation?

  object methods are just properties that have a value set to a function

  every function is called with a context


  *************************************************************************
  this

    'this' is automatically available to methods
    'this' is a reverence to the object itself
    'this' allows you to access and modify the properties of the object

    var car = {
      running: false,

      start: function() {
        this.running = true;
      },

      stop: function() {
        this.running = false;
      }
    }

    car.start();
    console.log(car);  // Object {running: true}

    car.stop();
    console.log(car);  // Object {running: false}


    running, start, stop all have the context of the global window object (car)
      and can access that global window object with 'this'
      if the global window object name (car) changes,
        the methods will retain access to the changed name through 'this'


    *************************************************************************
    difference between function and method invocations

      car.start(), car.stop() are method invocations
        car is the receiver

      car.start;                     // method invocation
      var startingCar = car.start;   // var to point at the method invocation
      startingCar()                  // funciton invocation


    *************************************************************************
    mutating Objects

      function increment(thing) {
        thing.num += 1;
      }

      var boxes = { count: 1 };
      var cans = { count: 4 };

      increment(boxes);

      even though 'thing' is inside a function it can mutate the boxes count
      both 'thing' and 'boxes' hold reference to the same object
        when the count is changed the references still point to the same object and reflect the change


*************************************************************************
*factory functions

  creating objects using functions

  function car(mpg, currentGas) {
    mpg : mpg,
    gasTank : currentGas,
    drive : function(miles) {
      this.gasTank - (miles / this.mpg)
    }
  }

  sedan = car(34, 12);
  sedan.drive(64)
  sedan.gasTank   // 10;

  factory functions allow you to make multiple instances of a car and instanciate different propertiy values

  coupe = car(17, 12)
  sedan.drive(64)
  sedan.gasTank   // 8


*************************************************************************
*object oriented programing

  object oriented programing allows you re-use patterns as the basic building blocks of code
  this is safer than using local variables or functions


  example : non OOP
    each var has to have a unique name because it is in the same scope
    we need to know the vehicle range which is mpg * fuel

    var smallCarFuel = 7.8;
    var smallCarMpg = 37;

    var largeCarFuel = 9.4;
    var largeCarMpg = 29;

    var truckFuel = 14.3;
    var truckMpg = 23;

    function vehicleRange(fuel, mpg) {
      return fuel * mpg;
    }

    vehicleRange(smallCarFuel, smallCarMpg); // => 288.6
    vehicleRange(largeCarFuel, largeCarMpg); // => 272.6
    vehicleRange(truckFuel, truckMpg);       // => 328.9


  example : OOP
    we reorganize related data into an object
    the relationship between mpg and fuel becomes clearer
    behaviors are placed in the object
    notice how many fewer var names
    objects can perform opperations on the data they own
    the code is easer to read and understand than the non OOP example


    function makeVehicle(fuel, mpg) {
      return {
        fuel: fuel,
        mpg: mpg,
        range: function() {
          return this.fuel * this.mpg;
        }
      };
    }

    var smallCar = makeVehicle(7.8, 37);
    smallCar.range();   // => 288.6

    var largeCar = makeVehicle(9.4, 29);
    largeCar.range();   // => 272.6

    var truck = makeVehicle(14.3, 23);
    truck.range();      // => 328.9


  OOP makes it easier to understand these questions

    | What are the important concepts in the code?
    | What are the properties of a vehicle?
    | How is a vehicle created?
    | What operations can I perform with a vehicle?
    | Where should new properties and methods affecting vehicles be added to the code?


  *************************************************************************
  key points

    |  Object-oriented programming is a pattern that uses objects to organize code
    |    instead of procedures or Functions.
    |    Unlike procedures and functions, objects can also contain data.
    |
    |  A function contained in an object is called a method.
    |
    |  Methods can be added to an object at any time, just like any other property.
    |
    |  When an object's methods are invoked, they can access the object they belong to by using this.

    |  Objects become more useful as projects become larger and more complicated.


*************************************************************************
*function contexts and objects

  key point
    javascript has first class functions, meaning they ..

      | can be added to objects and executed in the context of those objects
      | can be removed from their objects, passed around, and executed in completely different contexts
      | are initially unbound to any object, but are dynamically provided a context when they are executed.



*************************************************************************
*global object

  global objects or variables are added to the global object as properties


  window is the global object in the browser it has its own functions
    window.alert()
    window.prompt()
    window.confirm()
    window.open()

  window also has access to global values such as
    window.parseInt()
    window.isNaN()
    window.Infinity()

  or even add properties
  window.foo = 1;

  when you assign foo without a var declaration it is implicitly defined in the global scope
    foo = 1;          (is actually)
    window.foo = 1;


  when a global variable is created without var declaration and
    implicitly placed in the global scope you can delete it

    foo = 1;
    window.foo   // 1
    delete foo   // true

  if var delcaration is made you can't delete it
  the same is true with functions

    var foo = 1;
    window.foo;  // 1
    delete foo   // false


*************************************************************************
*Implicit function execution context  (aka implicit binding for functions)

  if 'this' is not a part of an object becomes binded with the implicit global context

  when the finction binds 'this' to the global(window) object implicitly
    if the function is called as a method inside an object it is bound to that object instead (not implicit binding)

  context object => the object that 'this' binds to

    function foo() {
      return 'this here is: ' + this;  // 'this' references the global object
    }

    console.log(foo());                // "this here is: [object Window]"

    the function foo has a execution context (has been implicitly binded) to the global object
    window.foo()


  not implicitly binded example
  if the function is inside a defined object 'this' will be binded to that object instead

    var obj = {
      foo: function() {
        return 'this here is ' + this  // the context object of 'this' is obj object
      }
    }

    console.log(obj.foo());            // this here is: [object Object]


  the context object is not determined(bound) when the function is defined but when the funciton is executed

    var bar = obj.foo;

    console.log(bar());                // this here is: [object Window]

    the context object of bar() implicitly binds to the global window not the obj context


*************************************************************************
call and apply

  call allows us to specify the execution context when a function is executed
    apply is similar to call only that it accepts an array as arguments
      someObject.someMethod.apply(context, [arg1, arg2, arg3..])

    var a = 1;

    obj = {
      a: 'hello',
      b: 'world',
    }

    function foo() {
      return 'this here is ' + this
    }

    foo();                            // this here is [object Window]

    foo.call(obj)                     // this here is [object Object]



  call allows you to use a function inside of one object to use with multiple objects

    calculate = {
      name: null,
      numbers: [],
      add: function() {
        return this.numbers.reduce(function(sum, num) {
          return sum += num;
        })
      },
    }

    obj1 = {
      name: 'bill',
      numbers: [3,2,3,4],
    }

    calculate.add.call(obj1);       // 15


  arguments are specified after the call context

    calculate = {
      name: null,
      numbers: [],
      add: function(type) {
        return this.name + ' ' + type + ' $' + this.numbers.reduce(function(sum, num) {
          return sum += num;
        })
      },
    }

    person1 = {
      name: 'bill',
      numbers: [3,2,3,4],
    }

    person2 = {
      name: 'julia',
      numbers: [3,1,3,9],
    }

    console.log(calculate.add.call(person1, 'paid'));
    console.log(calculate.add.call(person2, 'owes'));


*************************************************************************
*hard binding functions with contexts

  call and apply allow us to specify the execution context when a funciton is executed

  bind allows us to permently bind a function to it's context object
    when we use bind we are working with a fixed (function) return value, and can store it as a value


  var a = 1;

  obj = {
    a : 'hello',
    b : 'world',
    greet: function() {
      console.log(this.a + ' ' + this.b);
    }
  }

  var foo = obj.greet.bind(obj)    // binds foo to the obj

  obj2 = {
    a: 'good',
    b: 'bye',
  }

  foo.call(obj2);                  // call(obj2) is ignored, foo is still bound to obj


  bind() is not is not executing a function but returns a new funciton with 'thit' permently bound
    this allows us to pass around the function knowing that its context won't change


  example:

  var greetings = {
    morning: 'Good morning, ',
    afternoon: 'Good afternoon, ',
    evening: 'Good evening, ',

    greeting: function(name) {
      var currentHour = (new Date()).getHours();

      if (currentHour < 12) {
        console.log(this.morning + name);
      } else if (currentHour < 18) {
        console.log(this.afternoon + name);
      } else {
        console.log(this.evening + name);
      }
    },
  };

  var spanishWords = {
    morning: 'Buenos días, ',
    afternoon: 'Buenas tardes, ',
    evening: 'Buena noches, ',
  }

  var spanishGreeter = greetings.greeting.bind(spanishWords);

  spanishGreeter('Jose');      // Buenas tarde Jose
  spanishGreeter('Juan');      // Buenas tarde Jose

  greetings.greeting('Nate');  // Good afternoon Nate
  greetings.greeting('Julia'); // Good afternoon Julia



*************************************************************************
*dealing with context loss (3 parts)

  (review) changing the context of a function

    three ways of defining the execution context of a function
      1. call or apply the object to the function
      2. bind the function to an object and assign the return value to a variable that can be re-used
      3. change the execution context of a function by assigning it to a variable in an object (creating a method)


  *************************************************************************
  dealing with context loss (1)

    Taking a method out of an object
    two solltions (call/apply or bind)

    Solution 1: passing the context with the function and then calling or applying the context


      function repeatThreeTimes(func, context) {
        func.call(context);       // the context is out of scope can't do func.call(john) unless context is passed in
        func.call(context);
        func.call(context);
      }

      function foo() {
        var john = {
          firstName: 'John',
          lastName: 'Doe',
          greetings: function() {
            console.log('hello, ' + this.firstName + ' ' + this.lastName);
          },
        };

        repeatThreeTimes(john.greetings, john);
      }

      foo();


    Solution 2: hard binding the object (john) to the function being passed

      function repeatThreeTimes(func) {
        func();       // func() can be called because john is bound to john.greetings
        func();
        func();
      }

      function foo() {
        var john = {
          firstName: 'John',
          lastName: 'Doe',
          greetings: function() {
            console.log('hello, ' + this.firstName + ' ' + this.lastName);
          },
        };

        repeatThreeTimes(john.greetings.bind(john));
      }

      foo();


  *************************************************************************
  dealing with context loss (2)

    problem:
      when function bar() is executed the context is attached to the global object instead of the obj

      obj = {
        a: 'hello',
        b: 'world',
        foo: function() {
          function bar() {
            console.log(this.a + ' ' + this.b);
          }

          bar();
        },
      };

      obj.foo();        // undefined undefined


    solution (1):
      assign a new var 'self' to 'this' where bar() has access to the lexical scope of 'self'

      obj = {
        a: 'hello',
        b: 'world',
        foo: function() {
          var self = this;

          function bar() {
            console.log(self.a + ' ' + self.b);
          }

          bar();
        },
      };

      obj.foo();        // hello world


    solution (2):
      specify the exectution context of bar using bar.call(this)

      obj = {
        a: 'hello',
        b: 'world',
        foo: function() {
          function bar() {
            console.log(this.a + ' ' + this.b);
          }

          bar.call(this);
        },
      };

      obj.foo();        // hello world


    solution (3):
      use bind(this) to the function and store the binded function in a var
      bind has the additional advantage of only needing to be bound once and can be called multiple times anywhere

      obj = {
        a: 'hello',
        b: 'world',
        foo: function() {
          var bar = function bar() {
            console.log(this.a + ' ' + this.b);
          }.bind(this);

          bar();
        },
      };

      obj.foo();        // hello world



  *************************************************************************
  dealing with context loss (3)

    problem:
      it is common to call a function inside a method
      but the 'this' context is not preserved during the function execution
        there are three ways to fix this (same as previous examples)

        obj = {
          a: 'hello',
          b: 'world',
          foo: function() {
            [1, 2, 3].forEach(function(number) {
              console.log(String(number) + ' ' + this.a + ' ' + this.b);
            });
          },
        };

        obj.foo();


      solution (1)

        obj = {
          a: 'hello',
          b: 'world',
          foo: function() {
            var self = this;
            [1, 2, 3].forEach(function(number) {
              console.log(String(number) + ' ' + self.a + ' ' + self.b);
            });
          },
        };

        obj.foo();


      solution (2)

        obj = {
          a: 'hello',
          b: 'world',
          foo: function() {
            [1, 2, 3].forEach(function(number) {
              console.log(String(number) + ' ' + this.a + ' ' + this.b);
            }.bind(this));
          },
        };

        obj.foo();


      solution (3)
        use the forEach optional thisArg argument

        obj = {
          a: 'hello',
          b: 'world',
          foo: function() {
            [1, 2, 3].forEach(function(number) {
              console.log(String(number) + ' ' + this.a + ' ' + this.b);
            }, this);
          },
        };

        obj.foo();


*************************************************************************
*gentle introduction of keyword 'this' blogpost notes
  https://rainsoft.io/gentle-explanation-of-this-in-javascript/

  (function invocation, method invocation, indirect invocation, bound function)

  intro

    the main difference between a function invocation and method invocation is a method invocation
      uses a property accessor to execute the function
        obj.propertyName()    // .propertyName() is the property accessor
        obj[propertyName]()

      a function invocation does not use a propty accessor
        myFunction()


  *************************************************************************
  function invocation
    if a value is a function and followed by () it is invoked
      example: Number()

    it is not the same as property accessor
      obj.doSomething()             // this is method invocation
      [1,5].join(',')               // this is a method invocation

    use strict allows you to prevent implicit function context execution
    if a function has 'use strict', 'this' will return undefined and not attach to the global object
    'use strict'; // enable the strict mode
      this also enables strict mode in any inner scopes

    function strict() {
      'use strict';
      console.log(this === undefined);   // true
    }




  *************************************************************************
  method invocation


  *************************************************************************
  indirect invocation


  *************************************************************************
  bound function




*************************************************************************
  (review) closure and named functions
    there are two syntaxes for creating a function
    both follow the same lexical scoping rules

    named function syntax
      function foo() {
        console.log('named function');
      }

    function expression syntax
      var foo = function() {
        console.log('function expression');
      }


*higher order functions
    is a function that works with other functions and does at least one of the two things
    it helps to think of javascript functions as values

      1. either accept a function as an argument
      2. or return a function


      example accept a function as an argument

        arr = [1, 4, 2, 3, 5]

        arr.forEach(
          function(value) { console.log(value + 1) }
        )

      example of function that returns a function

        function helloFactory() {
          return function() { console.log('hi ' + this) }
        }


*************************************************************************
*************************************************************************
*************************************************************************

*************************************************************************
*A Hierarchy of Nodes	
  The browser creates a body and head (as well as other corrections) if they aren't specified in the original html
  the dom (which is accessable through dev tools) will reflect any changes made by the broswer

  the dom is a hiearchy of nodes have object types that include elements, comments and text

  three most common types of dom objects

    1. elements     => example: html, p tags  (dom objects that include multiple element(tag) types)
    2. text nodes   => represent text (this also includes text nodes which are empty)
      -whitespace is created when a new line is made in the html (for example between <p></p> and <h1></h1> tags
      -whitespace text nodes are not displayed in html or visually in the brower but still count as nodes
    3. comments     => represent html comments
      (various less important types)

  selecting a node
    document.querySelector('p')  //  <p>a peom by john dunbar</p>

  accessing object type
    document.toString()          // "[object HTMLDocument]"

  dom nodes have propertiy names
    document.function nodeName            // "document" 
    p.nodeName                   // 'P'

  dom nodes have propertiy types
    document.nodeType            // 9
    p.nodeType                   // 1

    property types relate to object type
                          value
      Node.ELEMENT_NODE	  1	     An Element representing an HTML tag
      Node.TEXT_NODE    	3	     A Text node
      Node.COMMENT_NODE 	8	     A Comment node
      Node.DOCUMENT_NODE	9	     A Document node

  dom nodes have propertiy values (elements don't hold a value, objects with text type do)
    document.nodeValue           // null
    p.nodeValue                  // null
    p.childNodes[0].nodeValue    // 'a peom by john dunbar'  (value of a specific node)

  accessing text property values
    document.textContent         // null
    p.textContent                // 'a peom by john dunbar'
                                 // textContent selects all text nodes in the element including whitespace
    p.textContent.trim()         // whitespace can be removed with .trim()
    

*************************************************************************
*Node Properties	
*Determining the Type of a Node	

  All dom elements are nodes (elements, text, comments)
  they inherit their specific type from Nodes above them
    -they have their own properties and methods along with the properties and methods they inherit from Nodes above

  elemnts also have more specific element types(tags)
    <p>   => HTMLParagraphElement
    <div> => HTMLDivElement

  more node types
  EventTarget   => provides event-handling allowing ineraction 
  Node          => provides common behavior
    Text        => main subtypes (hold text)
    Element     => main subtypes (represent html tags from the original html document)

  accessing node type
    1. inside the console use     
         document.toString();                       // "[object HTMLDocument]" 
         p.toString();                              // "[object HTMLParagraphElement]"

         var a = document.querySelector('a');       (dosen't work with anchor tags thoug)
           a.toString()                             // 'www.google.com'  (actually returns the URL in the anchor)
           document.querySelector('a').constructor  // function HTMLAnchorElement() { [native code] } 

    2. inside code use instanceof
         p instanceof HTMLParagraphElement;         // true
         p instanceof HTMLAnchorElement;            // false

       you an also use broader types
         p instanceof HTMLElement;                  // true
         p instanceof Element;                      // true
         p instanceof Node;                         // true
         p instanceof SVGElement;                   // false


*************************************************************************
*traversing Nodes
  nodes are connected to each other through properties that point from one node to the next in defined relationships

  childNodes      => property that returns a live collection of all nodes beneath the parent  or null
  parentNode      => each child has a parent node property that points back to the parent     or null 
  firstChild      => equivelent to childNodes[0]                                              or null
  lastChild       => equivelent to childNodes[childNodes.length -1]                           or null

  others
  nextSibling     => equivelent to childNodes[n+1]                                            or null 
  previousSibling => equivelent to childNodes[n-1]                                            or null 


  walk the dom

      generic recursive function 

        function recurseAndLog(array) {
          if (array.length > 0) {
            console.log(array[0]);
            recurseAndLog(array.slice(1));
          }
        }

    when walking the dom we use dom nodes instead of an array

      example:

        function walk(node) {
          console.log(node);
          if (node.nextSibling) {
            walk(node.nextSibling);
          }
        }

        walk(document.body.firstChild);


      example: similar to forEach()

        function walk(node, callback) {                      // walk() calls the Function callback once for each node
          callback(node);                                    // do something with node

          for (var i = 0; i < node.childNodes.length; i++) { // for each child node
            walk(node.childNodes[i], callback);              // recursively call walk()
          }
        }                                                   

        walk(document.body, function(node) {                 // log the nodeName of every node
          console.log(node.nodeName);
        });

        this allowys you to preform operations like the following
          var words = [];

          walk(document, function(node) {
            if (node.nodeName === "P") {
              var text = node.firstChild.data.trim();
              var firstWord = text.split(" ")[0];
              words.push(firstWord);
            }
          });

          console.log(words);  // ["A", "The", "The", "Where", "And"] 
 
 

*************************************************************************
*element attributes

  getting and setting attributes

    var p = document.querySelector('p');
    p                                    // <p class="intro" id="simple">...</p>
    p.hasAttribute('id')                 // true
    p.getAttribute('id')                 // 'simple'
    p.setAttribute('id', 'complex');     
    p                                    // <p class="intro" id="complex">...</p>

  attribute properties

    javaScript exposes the following attributes of the DOM property 
      id, name, title, value

      var p = document.querySelector('p');
      p                 // <p class="intro" id="simple">...</p>
      p.id              // 'simple'
      p.className       // 'intro'    (class is a reserved name in javaScript so use className instead)

      p.name            // undefined  (usually invalid)    
      p.title           // undefined 
      p.value           // undefined  (usually invalid)

      p.id = 'complex'  
      p.id              // 'complex'
      p                 // <p class="intro" id="complex">...</p>
    

  working with classLists
    p                  // <p class="intro" id="simple">...</p>
    p.className        // 'intro'
    p.classList        // ['intro'] (returns an Array-like domTokenList object, usefull if there are multple classes)
    
      the following functions work on a domTokenList object
        add(name)      // adds a new name to classList
        remove(name)   // removes an existing name from classList
        toggle(name)   // if the name exists removes it from classList and returns false (current status of the name)
                          if the name doesn't exist adds it to classList and returns true
        contains(name) // returns if the name is in the classList
        length         // returns the length of the class list

  style
    you can also access and change style properties on an element
    style is not usually used, more common is toggling, adding or removing access to css properties

    p.style              // {alignContent: "", alignItems: "", alignSelf: "", alignmentBaseline: "", all: ""…}
                         // this actually returns all of the possible style properties as empty
    p.style.background   // ''
    p.style.background = 'green'  (the dom is updated and the screen show a green <p> background)
    p.style.background = null

    h1.style.lineHeight = '90px'  (camel case must be used for css hyphend properties)


**************************************************************************
*selecting elements

  document.querySelector()                      // select first element in the document by name
  document.querySelectorAll()                   // select all elements in the document by name

  document.getElementsByClassName('<selector>') // select all elements by class name
  document.getElementsByTagName('<selector>')   // returns all elements by tag name

  document.getElementById('<selector>')         // not plural becuase there should only be one id element

    with querySelectoryAll() you can select elements using the same selector pattern rules as css 
      querySelectorAll('div p.intro')          // selects all paragraphs with .intro class name inside a div 

    all of the dom selectors that can fetch multiple elements return array like structures
      but you should use a for loop to iterate overthem because forEach is not compatable with all browsers
      or make convert to an array
        var newArr = Array.prototype.slice.call(querySelectorResult);


  childElements (excludestext text nodes)
  body.children                             // returns all elements within the parent element
  body.children.length                      // returns element count 
  body.firstElementChild                    // returns first child element
  body.lastElementChild                     // returns last child element
  body.children[0].nextElementSibling       // returns next element sibling (previousNode.children[n + 1]) 
  body.children[0].lastElementSibling       // returns last element sibling (previousNode.children[n - 1]) 

  body.querySelector().textContent          // returns the text inside the selected elements 
                                            // .textContent does not work on querySelectorAll()
  body.querySelector().textContent = 'new text' // allows you to reassign text inside an element but 
                                            // replaces all text content in the element so if there is multple
                                            // lines of content select with span id and reasign by id



**************************************************************************
*creating adding and moving dom nodes

  
  p1 = document.createElement('p')            // creates an element by tag type (must be created on the document)
                                              // "[object HTMLParagraphElement]"
  t1 = document.createTextNode('sample text') // creates a text node (must be created on the document)
                                              // "[object Text]"
  p1.appendChild(t1);                         // <p>sample text</p>

  s2 = document.createElement('span')
  s2.textContent = 'span text'                // alternate way to append text to an element

  it is necessary to clone nodes because simply copying without cloneNode() it will still reference the orignal node
    if place a shallow copy on the page in a different place the original node will disapear
    true is the same as .cloneNode(deepClone)

    p2 = p1.cloneNode(true)                   // create a copy of an element with cloneNode(true)

  document.body.appendChild(p1)               // append to an element (body)

  You can't call document.appendChild; it causes an error. Use document.body.appendChild instead.
    

**************************************************************************
*synchronous and asynchronous

  synchronous code 
    runs sequentially(in order) fron top to bottom one line after the other
    the code never stops running until it is complete

  asynchronous code 
    does not run sequentially, part might run now, part might run later
    uses callback functions to run code later
    sometimes the call stack is not running any code while it is waiting for a callback

  virtual machine (sprocesses callback requests)
    code is sent from the call stack to the virtual machine, once complete it is sent to the callback que

  event loop 
    continuously checks for code in the callback que and passes callbacks to the call stack


  example: asynchronous function 

    function makeLogger(i, message) {          
      return function() {
        console.log(i + ' ' + message);       // returns a function combining the interval and message  
      }
    }

    function delay(intervals, message) {
      for (var i = 1; i <= intervals; i++) {
        logger = makeLogger(i, message);      // sends a request for a function from make logger
        setTimeout(logger, i * 1000);         // setTimout gets passed to the virtual machine
      }                                       // the call stack moves onto the next for loop iteration 
    }

    delay(5, 'seconds later');
      // 1 seconds later
      // 2 seconds later
      // ...

  example: functions that register code in the virtual machine (to be called back later) 

    setTimeout(func, interval)                // time delay before running code

    var id = setInterval(func, interval);     // continuous loop of time delay before running code
      clearInterval(id)                       // the setInterval() loop must be cleared


  example: setInterval and clearInterval 

    function startCounting() {
      var count = 0;
      var id = setInterval(function() {
        console.log(count += 1);
        if (count > 3) stopCounting(id);
      }, 1000) 
    }

    function stopCounting(id) {
      clearInterval(id); 
    }

    startCounting();


**************************************************************************
*user interfaces and events

  an event is something that happends on the page
    they can be triggered by the following
      1. the browser  => example: when the document loads
      2. but the user => example: clicking on a button

    the web application interface handles two things
      1. displaying the user interface
      2. handleing events

    event listiner (aka event handler)
      the code that is run in response to an event firing
        event fires => code is run

    'DOMContentLoaded' => an argument for an event listener (executes when the dom has been constructed)
      happens after the html has been parsed and javaScript has been evaluated
      and before the page displays on the screen and embeded assets are loaded

      'load' is another argument (for an event handler) that executes after all 
        html, javascript and embeded assets have been loaded but is not usually very practical

    example: document loaded browser trigger

      document.addEventListener('DOMContentLoaded', function() {
        console.log('page loaded'); 
      });


**************************************************************************
*event handlers / listeners

  an event listener is a function that is called by the javaScript runtime when an event happens
    they require the following four steps

    1. identify the event (usually the event is triggered by the user or the page)
    2. identify the target element (where the function will be applied to)
    3. define the function (how will the target element be manipulated)
    4. register the function as an event listener


    There are two ways to prevent an event handler from being run before the page has loaded
    both require wraping the event with DOMContenLoaded event listener

      1. Wrap a content loaded event listener around the event listener

        document.addEventListener('DOMContentLoaded', function() { 
          var button = document.getElementById('alert');                  
          button.addEventListener('click', displayAlert);                
        });

      2. set a global event handler  

        document.addEventListener('DOMContentLoaded', function() {        
          var button = document.getElementById('alert');                 
          button.onclick = displayAlert;
        });


  examples : 


    document.addEventListener('keypress', function(event) {
      document.body.textContent = `
        ${event.type}           // keypress
        ${event.currentTarget}  // [object HTMLDocument] 
        ${event.target}         // [object HTMLBodyElement]
        ${event.which}          // ASCII Key code
        ${event.shiftKey}       // boolean value (same with altKey, ctrlKey, metaKey)
      `;
    });

    keypress doesn't fire with certain events like backspace, alt, shift

    
    more properties of the event object for Mouse events

      clientX      // location of the mouse x axis
      clientY      // location of the mouse y axis


**************************************************************************
*event capturing and bubbling (event delegation)

  downsides to event handling 

    problem: 
      with event handleing it is sometimes impractical to place an event handler on every possible event
      you are also must wait until the DOMContentLoaded is complete
      if a new dom element is generated on the page later you have to remember to add an event handler to it 

    solution: event delegation (event capturing and bubbling)
      adding an event handler to a containing element that listens for events fired on all of it's children


  **************************************************************************
  event capturing and bubbling (event delegation)
    capturing     => the dom fires in succession moving inward
    target phase  => until it reaches its target
    bubbling      => and then moving outward
    
    capturing phase
    when you click on a nested element the dom fires an event an all of its parent elements starting with the window    
    target phase
    the event fired on the actual target

    bubbling phase
    then it turns around and fires an event on every single element in revers back to the window


  **************************************************************************
  capturing vs bubbling

    by default addEventListener() executes during the targed and bubbling phase

      document.addEventListener('click', function(event) {
        // listen for events during the targeting and bubbling phase
      });

    addEventListener() also takes a third optional argument this argument allows you to specify if 
    events should be fired during the bubbling phase(false is default) or catpturing phase(true)

     document.addEventListener('click', function(event) {
        // will listen for capturing events instaed of the default bubbling events
     }, true);    

    it is best practice to just use the default bubbling 


  **************************************************************************
  delegation

    one way to add event handlers to multiple elements

      addSelectorArr = querySelectorAll('.shared-class')

      for (var i = 0; i < addSelectorArr.length; i++) {
        addSelectorArr[i].addEventListener('click', function(event) {
          // do something with target
        }
      }
        
      however with this approach you have to wait until the dom is loaded to capture the arr of elements
        this can cause timing problems on a complex page
      if an additional element is added to the page later it will not be included in the for loop arr
        an additional event handler will have to be added


    using delegation (better)
    
      document.addEventListener('click', function(event) {
        var target = event.target;          // checks every possible target in the document
        if (target.tagName === 'BUTTON') {  // if the target meets the specification an event is preformed
          // do someting with target
        }
      }

      allows you to add an event handler to the entire document
      then check the tag name before applying the event

      delegation can also be added to parent elements insead of the entire document 
        if we only need to listen to elements that are children of the parent

      the tradeoff with event delegation is that sometimes it causes a lot of if else statements in the code
        this can become a problem in complex applications

      general rule is to start out binding elements individually and then as the code grows find areas where
        it is better to use event delegation
    

  **************************************************************************
  stop propagation

    allows you to apply an event handler to multple elements but only fires the event that the user interacts with
    it is bets to place stopPropagation() or the following preventDefault() in the beginning of the code
      which makes it easier to debug if there are errors and makes the code more explicit and easier to understand

    example :

      function turnRed(event) {
        event.stopPropagation();
        event.currentTarget.style.background = 'red';
      }

      document.addEventListener('DOMContentLoaded', function() {
        document.querySelector('.outer').addEventListener('click',  turnRed);    
        document.querySelector('.inner').addEventListener('click',  turnRed);
      }); 

    in this example only the first clicked box will turn red instead of both


  **************************************************************************
  prevent default

    allows you to specify an alternate event that the default

    example :

    <a href="/">View page</a>

    document.addEventListener('DOMContentLoaded', function() {
      document.querySelector('a').addEventListener('click', function(event) {
        event.preventDefault();
        alert('Following the link was prevented.');
      });
    })

    this example give a pop up window instead of following the link

   
