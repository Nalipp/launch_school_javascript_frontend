*************************************************************************
  front_end_javascript_master_notes
*************************************************************************

  // objects and function scope
*objects and methods ( this )
*factory functions
*object oriented programing ( key points )
*function contexts and objects
*global object
*Implicit function execution context
*hard binding functions with contexts
*dealing with context loss (3 parts)
*gentle introduction of keyword 'this' blogpost notes
  // closures and function scope
*higher order functions
*closures and private data
*objects and closure
*garbage collection	
*readings on closures
*partial function application
*immediately invoked function expressions
  // The DOM	
*the Dom
*A Hierarchy of Nodes	
*Node Properties	
*Determining the Type of a Node	
*traversing Nodes
*element attributes
*selecting elements
*creating adding and moving dom nodes
  // event-driven and asynchronous programing
*synchronous and asynchronous (asynchronous gotcha)
*user interfaces and events
*event handlers / listeners
*event capturing and bubbling (event delegation)


*************************************************************************
  // objects and function scope
*************************************************************************
*objects and methods ( this )

  methods   => functions with a receiver
  functions => no reciever

  object methods are just properties that have a value set to a function

  every function is called with a context (the context is the reciever object)

    if a function is a the value of an object parameter it is a method and the reciever is the object
    all functions have a reciever, if it is a method the object context is the reciever
    if the function is not a part of an object the object context is the global window
    a function can be passed around and be assigned a reciever dynamically
    the object name is the context of the function 

    What is the context of a function?    => the name of the receiver object

  what is the difference between function invocation and method invocation?


  every function has a context automatically assigned at execution time i.e. ()
  such as the global window or the object the function is being called in
    the function context/reciever can be called with 'this'

  'this' is always avaiable when a method executes
    it is also available during function invocation

  when an object has a function set as a parameter value, the reciever/calling obj to that method is the object
  if the function is not a part of an object it is not a method and has no reciever

  example :

    greeter.greeting           // [Function:morning]  no invocation            returns a function
    greeter.greeting()         // 'good morning'      method invocation        executes the function

    var g = greeter.greeting
    g()                        // 'good morning'      function invocation      executes the function


  *************************************************************************
  this

    'this' is automatically available to methods
    'this' is a reference to the object itself
    'this' allows you to access and modify the properties of the object

    example:

      var car = {
        running: false,
        start: function() {
          this.running = true;
        },
        stop: function() {
          this.running = false;
        }
      }

      car.start();
      console.log(car);  // Object {running: true}

      car.stop();
      console.log(car);  // Object {running: false}


    running, start, stop all have the context of the global window object (car)
      and can access that global window object with 'this'
      if the global window object name (car) changes,
        the methods will retain access to the changed name through 'this'
        i.e. you can change the var name car and still retain access to the object 

    example :

      var person = {
        firstName: 'joe',
        lastName: 'smith',
        upperName: function() {
          console.log(person.firstName.toUpperCase(), person.lastName.toUpperCase());
        }
      }

      person.upperName();    // 'JOE SMITH'

    but if you reassign the person object to another name the method will no longer work,
    so it is better to use 'this'

      var people = {
        firstName: 'joe',
        lastName: 'smith',
        upperName: function() {
          console.log(this.firstName.toUpperCase(), this.lastName.toUpperCase());
        }
      }

      people.upperName();    // 'JOE SMITH'


    *************************************************************************
    difference between function and method invocations

      car.start(), car.stop() are method invocations
        car is the receiver

      car.start;                     // method invocation
      var startingCar = car.start;   // var to point at the method invocation
      startingCar()                  // funciton invocation


    *************************************************************************
    mutating Objects

      function increment(thing) {
        thing.num += 1;
      }

      var boxes = { count: 1 };
      var cans = { count: 4 };

      increment(boxes);

      even though 'thing' is inside a function it can mutate the boxes count
      both 'thing' and 'boxes' hold reference to the same object
        when the count is changed the references still point to the same object and reflect the change


*************************************************************************
*factory functions

  basically when an function takes an argument(optional), then creates and returns an object

  creating objects using functions

  function car(mpg, currentGas) {
    return {
      mpg : mpg,
      gasTank : currentGas,
      drive : function(miles) {
        this.gasTank - (miles / this.mpg)
      }
    }
  }

  sedan = car(34, 12);
  sedan.drive(64)
  sedan.gasTank   // 10;

  factory functions allow you to make multiple instances of a car and instanciate different propertiy values

  coupe = car(17, 12)
  sedan.drive(64)
  sedan.gasTank   // 8


*************************************************************************
*object oriented programing

  object oriented programing allows you re-use patterns as the basic building blocks of code
  this is safer than using local variables or functions

  when we use objects it allows us to place behavior that manipulates the data of the object inside of the object
  we can use 'smart objects' that can preform actions on the data they own
  this allows us to move complexity inside of enclosed objects instead of the global scope

  with oop  
    we reorganize related data and code into an object
    behaviors are placed in the object
    we have fewer var names
    the code is easer to read and understand 
    are especially useful when a program needs multiple instances of something


  example : non OOP
    each var has to have a unique name because it is in the same scope
    we need to know the vehicle range which is mpg * fuel

    var smallCarFuel = 7.8;
    var smallCarMpg = 37;

    var largeCarFuel = 9.4;
    var largeCarMpg = 29;

    var truckFuel = 14.3;
    var truckMpg = 23;

    function vehicleRange(fuel, mpg) {
      return fuel * mpg;
    }

    vehicleRange(smallCarFuel, smallCarMpg); // => 288.6
    vehicleRange(largeCarFuel, largeCarMpg); // => 272.6
    vehicleRange(truckFuel, truckMpg);       // => 328.9


  example : OOP

    function makeVehicle(fuel, mpg) {    // first we create an factory function
      return {
        fuel: fuel,
        mpg: mpg,
        range: function() {
          return this.fuel * this.mpg;
        }
      };
    }

    var smallCar = makeVehicle(7.8, 37);
    smallCar.range();   // => 288.6

    var largeCar = makeVehicle(9.4, 29);
    largeCar.range();   // => 272.6

    var truck = makeVehicle(14.3, 23);
    truck.range();      // => 328.9


  OOP makes it easier to understand these questions

    | What are the important concepts in the code?
    | What are the properties of a vehicle?
    | How is a vehicle created?
    | What operations can I perform with a vehicle?
    | Where should new properties and methods affecting vehicles be added to the code?


  *************************************************************************
  key points

    |  Object-oriented programming is a pattern that uses objects to organize code
    |    instead of procedures or Functions.
    |    Unlike procedures and functions, objects can also contain data.
    |
    |  A function contained in an object is called a method.
    |
    |  Methods can be added to an object at any time, just like any other property.
    |
    |  When an object's methods are invoked, they can access the object they belong to by using this.
    |
    |  Objects become more useful as projects become larger and more complicated.


*************************************************************************
*function contexts and objects

  key point
    javascript has first class functions, meaning they they can be passed around like values
    functions can be invoked in different contexts (with different recievers)
    when a function is created it does not have a context, the context is created when the function is invoked

    because functions are first class, they...
      | can be added to objects and executed in the context of those objects
      | can be removed from their objects, passed around, and executed in completely different contexts
      | are initially unbound to any object, but are dynamically provided a context when they are executed.


  javascript is both a OOP langauge and a language with first class functions
    the developer must control the context of the functions


*************************************************************************
*global object

  window is the global object in the browser
  global is the global object in Node (terminal) environment

  global objects or variables are added to the global object as properties

  window is the global object in the browser it already has its own functions
    window.alert()
    window.prompt()
    window.confirm()
    window.open()

  window also has access to global values such as
    window.parseInt()
    window.isNaN()
    window.Infinity()

  or even add properties
  window.foo = 1;

  when you assign foo without a var declaration it is implicitly defined in the global scope
    foo = 1;          (is actually)
    window.foo = 1;   (it belongs to the global object context)


  when a global variable is created without var declaration and
    implicitly placed in the global scope you can delete it

    foo = 1;
    window.foo   // 1
    delete foo   // true

  if var delcaration is made you can't delete it
  the same is true with functions

    var foo = 1;
    window.foo;  // 1
    delete foo   // false

  | It's as though JavaScript tries to hide the fact these variables are global object properties!

*************************************************************************
*Implicit function execution context  (aka implicit binding for functions)

  if 'this' is not a part of an object it becomes binded with the implicit global context

  'object implicitly' is when the finction binds 'this' to the global(window) 
  'not implicit binding' is when the function is called as a method inside an object and is bound to that object

  context object => the object that 'this' binds to

    function foo() {
      return 'this here is: ' + this;  // 'this' references the global object
    }

    console.log(foo());                // "this here is: [object Window]"

    the function foo has a execution context (has been implicitly binded) to the global object
    window.foo()


  not implicitly binded example
  if the function is inside a defined object 'this' will be binded to that object instead

    var obj = {
      foo: function() {
        return 'this here is ' + this  // the context object of 'this' is obj object
      }
    }

    console.log(obj.foo());            // this here is: [object Object]


  the context object is not determined(bound) when the function is defined but when the funciton is executed

    var bar = obj.foo;

    console.log(bar());                // this here is: [object Window]

    the context object of bar() implicitly binds to the global window not the obj context


*************************************************************************
call and apply

  call allows us to specify the execution context when a function is executed
    apply is similar to call only that it accepts an array as arguments
    call still accepts arguments but not as an array?
      someObject.someMethod.apply(context, [arg1, arg2, arg3..])

    var a = 1;

    obj = {
      a: 'hello',
      b: 'world',
    }

    function foo() {
      return 'this here is ' + this
    }

    foo();                            // this here is [object Window]

    foo.call(obj)                     // this here is [object Object]



  call allows you to use a function inside of one object to use with multiple objects

    calculate = {
      name: null,
      numbers: [],
      add: function() {
        return this.numbers.reduce(function(sum, num) {
          return sum += num;
        })
      },
    }

    obj1 = {
      name: 'bill',
      numbers: [3,2,3,4],
    }

    calculate.add.call(obj1);       // 15


  arguments are specified after the call context

    calculate = {
      name: null,
      numbers: [],
      add: function(type) {
        return this.name + ' ' + type + ' $' + this.numbers.reduce(function(sum, num) {
          return sum += num;
        })
      },
    }

    person1 = {
      name: 'bill',
      numbers: [3,2,3,4],
    }

    person2 = {
      name: 'julia',
      numbers: [3,1,3,9],
    }

    console.log(calculate.add.call(person1, 'paid'));
    console.log(calculate.add.call(person2, 'owes'));


*************************************************************************
*hard binding functions with contexts

  call and apply allow us to specify the execution context when a funciton is executed

  bind allows us to permently bind a function to it's context object
    when we use bind we are working with a fixed (function) return value, and can store it as a value

  difference between bind and call
    call allows you to specify the context of a function
    bind allows you to bint the context object of a function permenently so that the function can be passed around
      the context will not be implicity changed or changed explicity (even call does not work on a binded function)

  with bind the function is not being invoked, bind returns a copy of the function with 'this' defined permently


  var a = 1;

  obj = {
    a : 'hello',
    b : 'world',
    greet: function() {
      console.log(this.a + ' ' + this.b);
    }
  }

  var foo = obj.greet.bind(obj)    // binds foo to the obj

  obj2 = {
    a: 'good',
    b: 'bye',
  }

  foo.call(obj2);                  // call(obj2) is ignored, foo is still bound to obj


  bind() is not executing a function but returns a new funciton with 'this' permently bound
    this allows us to pass around the function knowing that its context won't change


  example:

  var greetings = {
    morning: 'Good morning, ',
    afternoon: 'Good afternoon, ',
    evening: 'Good evening, ',

    greeting: function(name) {
      var currentHour = (new Date()).getHours();

      if (currentHour < 12) {
        console.log(this.morning + name);
      } else if (currentHour < 18) {
        console.log(this.afternoon + name);
      } else {
        console.log(this.evening + name);
      }
    },
  };

  var spanishWords = {
    morning: 'Buenos días, ',
    afternoon: 'Buenas tardes, ',
    evening: 'Buena noches, ',
  }

  var spanishGreeter = greetings.greeting.bind(spanishWords);

  spanishGreeter('Jose');      // Buenas tarde Jose
  spanishGreeter('Juan');      // Buenas tarde Jose

  greetings.greeting('Nate');  // Good afternoon Nate
  greetings.greeting('Julia'); // Good afternoon Julia



*************************************************************************
*dealing with context loss (3 parts)

  context loss happens when a the context of a function is not explicity made called resulting in the context being
    inplicitly binding to the global window 
    this can happen when a function is called inside a function
    this is because an inner function does not have the same context as an outer function, 
      the inner function context must be explicity defined
    a function call insiede of a method function call does not inherit the context of the parent method invocation
      when the inner function is invoked it inexplicity uses the global context (or undfined in use strict mode)
      it is a function invocation not a method invocation


  (review) changing the context of a function

    three ways of defining the execution context of a function
      1. call or apply the object to the function
      2. bind the function to an object and assign the return value to a variable that can be re-used
      3. change the execution context of a function by assigning it to a variable in an object (creating a method)


  *************************************************************************
  dealing with context loss (1)

    Taking a method out of an object
    two solltions (call/apply or bind)

    Solution 1: passing the context with the function and then calling or applying the context


      function repeatThreeTimes(func, context) {
        func.call(context);   // the context is out of scope can't do func.call(john) unless context is passed in
        func.call(context);
        func.call(context);
      }

      function foo() {
        var john = {
          firstName: 'John',
          lastName: 'Doe',
          greetings: function() {
            console.log('hello, ' + this.firstName + ' ' + this.lastName);
          },
        };

        repeatThreeTimes(john.greetings, john);
      }

      foo();


    Solution 2: hard binding the object (john) to the function being passed

      function repeatThreeTimes(func) {
        func();       // func() can be called because john is bound to john.greetings
        func();
        func();
      }

      function foo() {
        var john = {
          firstName: 'John',
          lastName: 'Doe',
          greetings: function() {
            console.log('hello, ' + this.firstName + ' ' + this.lastName);
          },
        };

        repeatThreeTimes(john.greetings.bind(john));
      }

      foo();
   

     Alternate example

      with bind you don't have to use objects to define the this context, bind works with just a funciton

      var temperatures = [53, 86, 12, 43];

      function average() {
        var total = 0;
        for (var i = 0; i < this.length; i++) {
          total += this[i];
        }

        return total / this.length;
      }

      var averageTemps = average.bind(temperatures);
      console.log(averageTemps());                        // 48.5

  *************************************************************************
  dealing with context loss (2)

    problem:
      when function bar() is executed the context is attached to the global object instead of the obj
      this is because there is no explicit context provided for bar so bar is binded to the global object
        since the context for foo is provided the context for bar should propagate but it dosen't (langauge flaw)

      obj = {
        a: 'hello',
        b: 'world',
        foo: function() {
          function bar() {
            console.log(this.a + ' ' + this.b);
          }

          bar();
        },
      };

      obj.foo();        // undefined undefined


    solution (1):
      assign a new var 'self' to 'this' where bar() has access to the lexical scope of 'self'

      obj = {
        a: 'hello',
        b: 'world',
        foo: function() {
          var self = this;

          function bar() {
            console.log(self.a + ' ' + self.b);
          }

          bar();
        },
      };

      obj.foo();        // hello world


    solution (2):
      specify the exectution context of bar using bar.call(this)

      obj = {
        a: 'hello',
        b: 'world',
        foo: function() {
          function bar() {
            console.log(this.a + ' ' + this.b);
          }

          bar.call(this);
        },
      };

      obj.foo();        // hello world


    solution (3):
      use bind(this) to the function and store the binded function in a var
      bind has the additional advantage of only needing to be bound once and can be called multiple times anywhere

      obj = {
        a: 'hello',
        b: 'world',
        foo: function() {
          var bar = function bar() {
            console.log(this.a + ' ' + this.b);
          }.bind(this);

          bar();
        },
      };

      obj.foo();        // hello world



  *************************************************************************
  dealing with context loss (3)

    problem:
      it is common to call a function inside a method
      but the 'this' context is not preserved during the function execution
        there are three ways to fix this (same as previous examples)

        obj = {
          a: 'hello',
          b: 'world',
          foo: function() {
            [1, 2, 3].forEach(function(number) {
              console.log(String(number) + ' ' + this.a + ' ' + this.b);
            });
          },
        };

        obj.foo();


      solution (1)

        obj = {
          a: 'hello',
          b: 'world',
          foo: function() {
            var self = this;
            [1, 2, 3].forEach(function(number) {
              console.log(String(number) + ' ' + self.a + ' ' + self.b);
            });
          },
        };

        obj.foo();


      solution (2)

        obj = {
          a: 'hello',
          b: 'world',
          foo: function() {
            [1, 2, 3].forEach(function(number) {
              console.log(String(number) + ' ' + this.a + ' ' + this.b);
            }.bind(this));
          },
        };

        obj.foo();


      solution (3)
        use the forEach optional thisArg argument

        obj = {
          a: 'hello',
          b: 'world',
          foo: function() {
            [1, 2, 3].forEach(function(number) {
              console.log(String(number) + ' ' + this.a + ' ' + this.b);
            }, this);
          },
        };

        obj.foo();


*************************************************************************
*gentle introduction of keyword 'this' blogpost notes
  https://rainsoft.io/gentle-explanation-of-this-in-javascript/

  (function invocation, method invocation, indirect invocation, bound function)

  ****  'this' is the current execution context of function   ****

  intro

    the main difference between a function invocation and method invocation is a method invocation
      uses a property accessor to execute the function
        obj.propertyName()    // .propertyName() is the property accessor
        obj[propertyName]()

      a function invocation does not use a propty accessor
        myFunction()


  *************************************************************************
  function invocation
    if a value is a function and followed by () it is invoked
      example: Number()

    it is not the same as property accessor
      obj.doSomething()             // this is method invocation
      [1,5].join(',')               // this is a method invocation

    use strict allows you to prevent implicit function context execution
    if a function has 'use strict', 'this' will return undefined and not attach to the global object
    'use strict'; // enable the strict mode
      this also enables strict mode in any inner scopes

    function strict() {
      'use strict';
      console.log(this === undefined);   // true
    }


  *************************************************************************
  method invocation

    understanind the difference between a method invocation and a function invocation helps identify the context

    a method invocation uses a property accessor ( ., () )

      obj.myFunction = function() {        // function declaration
        return new Date().toString();
      };
      obj.myFunction();                    // method invocation


    'this' is the object that owns the method

    when using setTimout bind is necessary because the method looses it's context when it is passed as a parameter

    when you pass a method invocation as a parameter the context is lost
      therefor if the method invocation uses this the following will fail
        setTimout(myCat.logInfo)

        solution
        var extractedFunction = myCat.logInfo
        setTimeout(myCat.logInfo.bind(myCat), 1000);


  *************************************************************************
  indirect invocation
    
    uses <function>.cal() or <function>.apply()

    the first argument of an indirect function is 'this' 


  *************************************************************************
  bound function

    a function that is connected(bound) to an object ( usually crated with <function>.bind() method )

    example : binding to a function

      function multiply(number) {  
        return this * number;           when multiply() is binded to 5 on the following lines, 'this' is 5
      }

      var multiply5 = multiply.bind(5)
      console.log(multiply5(2));

    bind does not invoke the function immediatley ( unlike indirect invocations bind() and call() )
      instead it makes a copy of the bound function to be assigned to a variable and used later

    bind allows you to create funcitons with pre-defined 'this' values


*************************************************************************
  // closures and function scope
*************************************************************************
  (review) closure and named functions

    there are two syntaxes for creating a function
    both follow the same lexical scoping rules

    1. named function syntax

      function foo() {
        console.log('named function');
      }

    2. function expression syntax

      var foo = function() {
        console.log('function expression');
      }


*higher order functions

    a function that works with other functions
    and does at least one of two things

      1. either accepts a function as an argument
      2. or returns a function

      -think of functions as values

      example accept a function as an argument

        arr = [1, 4, 2, 3, 5]

        arr.forEach(
          function(value) { console.log(value + 1) }
        )

      example of function that returns a function

        function helloFactory() {
          return function() { console.log('hi ' + this) }
        }

      example: timed (logs the time it takes to run a function) 
        timed is a higher order function because it returns a funciton  
          and also because it accepts a function as an argument

        function timed(func) {
          return function() {
            var start = new Date();
            func();
            var stop = new Date();
            console.log((stop - start).toString() + " ms have elapsed");
          }
        }


        function loopy() {
          var sum = 0;
          for(var i = 0; i < 1000000000; i++) {
            sum += i;
          }
          console.log(sum);
        }

        var runTime = timed(loopy)();  // the timed higher order function allows us to run the program and store
                                          the return value so that it dosen't have to be ran each time

*************************************************************************
*closures and private data 

  (in the following examples we examin closures that return a function)
  
  closures refer to the context or the scope that exists when the function was created
  access to that scope persists regardless of where the function is executed later

  example : 

    function makeCounter() {
      var count = 0;
      return function() {
        count += 1;
        return count;
      }
    }

    var newCount = makeCounter()
    console.log(newCount());  // 1
    console.log(newCount());  // 2

  newCount retains access to the local variable 'count' that was in context when makeCounter() was created
    it is impossible to access count once the funtion is created
    count can only be manipulated through the methods that were defined when the closure was created


  the closure holds the context from when the function was created
    and reatains access to that context regardless of where the function is run later in the program


  example : when making a closure over private data you can also provide functions as arguments 
    
    function later(func, argument) {
      return function() {
        func(argument);
      }
    }

    var logWarning = later(console.log, 'The system is shutting down');
    logWarning();      // 'The system is shutting down');

*************************************************************************
*objects and closures

  (in the following examples we examin closures that return a objects)

  somtimes a single return function is not well suited for interacting with private data
    this can happen when there are multiple ways that the closre needs to manipulate the private data

  an object can be a better programing interface(API) for manipulating the private data of a closure

  the following two example contrast the two appraches


  1. example ( returning function that interacts with data in multple ways (bad) )

    function makeList() {
      var items = [];

      return function(newItem) {
        if (newItem) {
          var index = items.indexOf(newItem)
          if (index === -1) {
            items.push(newItem);
            console.log(newItem + ' added!');
          } else {
            items.splice(index, 1);
            console.log(newItem + ' removed!');
          }
        } else {
          if (items.length === 0) {
            console.log('There are no items in the list.');
          } else {
            items.forEach(function(item, index) {
              console.log((index + 1) + ': ' + item);
            });
          }
        }
      }
    }

    var list1 = makeList();

    list1('list item')  // adds a list item
    list1('list item')  // deletes a list item if it is on the list or adds
    list1()             // displays the list

    but hard to understand what does what


  2. example ( returning an object instead of a function (better) )

    function makeList() {
      var items = [];

      return {
        add: function(item) {
          items.push(item);
          console.log('"' + item + '"' + ' has been added') 
        },
        remove: function(item) {
          if (items.indexOf(item) !== -1) {
            items.splice(items.indexOf(item), 1);
            console.log('"' + item + '"' + ' has been deleted') 
          }
        },
        logList: function() {
          items.forEach(function(value, index) {
            console.log((index + 1) + ': ' + value);
          }); 
        },
      }
    }

    list1 = makeList();

    list1.add('bananas');      // adds to the list
    list1.logList();           // logs the list
    list1.remove('bananas');   // removes from the list
    list1.logList();           

    easier to undetstand that interface when we use an object instead of a single function

*************************************************************************
*garbage collection	

  garbage collection happens automatically when a variable is out of scope
  a variable goes out of scope when there is no longer any code that has access to it

  closures can cause an issue with automatic garbage collection because colsure continue to hold scope on variables
  any reference to a variable inside a closure must be removed 
    before memory used to store the variable can be deallocated

  common way to remove a copy of a funciton(closure) is to set it to null
    this removes the reference to any private variables contained in the closure

    list1() = null;
  

*************************************************************************
*readings on closures

  why use "closure"?   https://howtonode.org/why-use-closure
  mdn documentation    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Practical_closures 


  *************************************************************************
  why use "closure"?

    closures allow you to maintain state across event calls

    a closure is a first class function with variables that are bound to the lexical environment
    a closure closes over the variables in its lexical scope

    a closure is a function within an outer scope(another function) 
      that has access to the outer variables of that scope(another function)

    exmaple: generating a closure
    var bobGreeter = greeter("Bob", 47);     // 'var bobGreeter' is the closure

    a factory function that returns a function is similar to a class in OOP
      one thing to remember is that each insteance of the factory function (class) has it's own set of functions
        so it is not a good idea to use factory functions where there is a lot of instances


  *************************************************************************
  mdn documentation    

    closures allow encapsulation and data hidding similar to objects(classes) in oop

    closure allow you to associated variables (withing a lexical scope) with a function that operates on that data
    closures are similar to OOP objects where data(properties) is associated with methods(properties) on the data

    closures can be used where objects can be used

    there is not a native way to keep variables private in javaScript(5) but this can be emulated through closures
      you can create a closure that exposes a public api that opperates on the private data
      methods in the closure are clear of the global namespace
      public functions can access both private data and private functions


*************************************************************************
*partial function application

  when a funciton is invoked with some arguments defined and allows for other artguments to be defined later 

    example:

    function makeAddN(addend) {    // addend is defined when the closure is created
      return function(number) {    // number is defined later when the closure is invoked 
        return addend + number;
      }
    }

    var add1 = makeAddN(1);
    add1(1);                           //  2
    add1(41);                          //  42

    var add9 = makeAddN(9);
    add9(1);                           //  10
    add9(9);                           //  18


    example : partial function that uses a function(greet) as an argument
              passing functions to a partial function this example allows you to combine a permenent argument value
                with a function that performs an opperation on the permenent value and a later specfied argument 

      function greet(greeting, name) {
        return greeting + ' ' + name;
      }

      function greetFactory(func, permGreeting) {
        return function(name) {
          return func(permGreeting, name);
        }
      }

      var sayHello = greetFactory(greet, 'hello');
      var sayHi = greetFactory(greet, 'hi');

      console.log(sayHello('Brandon'));    // Hello, Brandon!
      console.log(sayHi('Sarah'));         // Hi, Sarah!

*************************************************************************
*immediately invoked function expressions
  
    surrounding a function with parenthesis immediately invokes the function
    without the parenthesis it is just a function expression with no name (error)

    in javaScript parenthesis do not change values

      (function() {
        console.log('hello');
      })();                     // hello

    the parenthesis () after the function all the function immediatley and can accept arguments

      (function(name) {
        console.log('hello' + name);
      })('matt');                     // hello matt

      var foo = function() {
        return 'hello'; 
      }();

      console.log(foo());

    if the IIFE is not at the beginning of the line the parenthesis can be ommited 

      var foo = function() {
        return function() {
          console.log(10);
        }();
      }();

      foo()       // 10

    IIFE can be useful for creating private scope

      it is not good to place variables(or code) in the global scope so 
      IIFE can be useful because it creates its own scope and can run without being called

        var i = 20;         (i pollutes the global scope)


      wraping the variables / code in a function also creates a private scope 
        but the function is now in the global scope which is also not desirable 

        function varI() {  (now the function declaration pollutes the global scope)
          var i = 20;      (this could be a problem if there is another function with the same name)
        }
        varI():

        this can be soved with an IIFE where the function dosen't need a name

        (function(num) {    (better)
          var i = 20;
          return i + num    
        })(5);              // 100



*************************************************************************
  // The DOM	
*************************************************************************
*the Dom
  
  in an in-memory object that that represents an html document

  this in-memory representation can be viewed in dev tools

  javaScript can manipulate the dom

  dom properties ( when manipulated with javascript i.e. addEventListener() ) allow us to watch for events

*************************************************************************
*A Hierarchy of Nodes	

  The browser creates a body and head (as well as other corrections) if they aren't specified in the original html
  the dom (which is accessable through dev tools) will reflect any changes made by the broswer

  the dom is a hiearchy of nodes have object types that include elements, comments and text

  three most common types of dom objects

    1. elements     => example: html, p tags  (dom objects that include multiple element(tag) types)
    2. text nodes   => represent text (this also includes text nodes which are empty)
      -whitespace is created when a new line is made in the html (for example between <p></p> and <h1></h1> tags
      -whitespace text nodes are not displayed in html or visually in the brower but still count as nodes
    3. comments     => represent html comments
      (various less important types)

  selecting a node
    document.querySelector('p')  //  <p>a peom by john dunbar</p>

  accessing object type
    document.toString()          // "[object HTMLDocument]"

  dom nodes have propertiy names
    document.nodeName            // "document" 
    p.nodeName                   // 'P'

  dom nodes have propertiy types
    document.nodeType            // 9
    p.nodeType                   // 1

    property types relate to object type
                          value
      Node.ELEMENT_NODE	  1	     An Element representing an HTML tag
      Node.TEXT_NODE    	3	     A Text node
      Node.COMMENT_NODE 	8	     A Comment node
      Node.DOCUMENT_NODE	9	     A Document node

  dom nodes have propertiy values (elements don't hold a value, objects with text type do)
    document.nodeValue           // null
    p.nodeValue                  // null
    p.childNodes[0].nodeValue    // 'a peom by john dunbar'  (value of a specific node)

  accessing text property values
    document.textContent         // null
    p.textContent                // 'a peom by john dunbar'
                                 // textContent selects all text nodes in the element including whitespace
    p.textContent.trim()         // whitespace can be removed with .trim()
    

*************************************************************************
*Node Properties	
*Determining the Type of a Node	

  All dom elements are nodes (elements, text, comments)
  they inherit their specific type from Nodes above them
    -they have their own properties and methods along with the properties and methods they inherit from Nodes above

  elemnts also have more specific element types(tags)
    <p>   => HTMLParagraphElement
    <div> => HTMLDivElement

  more node types
  EventTarget   => provides event-handling allowing ineraction 
  Node          => provides common behavior
    Text        => main subtypes (hold text)
    Element     => main subtypes (represent html tags from the original html document)

  accessing node type
    1. inside the console use     
         document.toString();                       // "[object HTMLDocument]" 
         p.toString();                              // "[object HTMLParagraphElement]"

         var a = document.querySelector('a');       (dosen't work with anchor tags thoug)
           a.toString()                             // 'www.google.com'  (actually returns the URL in the anchor)
           document.querySelector('a').constructor  // function HTMLAnchorElement() { [native code] } 
           a.tagName                                // 'A'

    2. inside code use instanceof
         p instanceof HTMLParagraphElement;         // true
         p instanceof HTMLAnchorElement;            // false

       you an also use broader types
         p instanceof HTMLElement;                  // true
         p instanceof Element;                      // true
         p instanceof Node;                         // true
         p instanceof SVGElement;                   // false


*************************************************************************
*traversing Nodes
  nodes are connected to each other through properties that point from one node to the next in defined relationships

  childNodes      => property that returns a live collection of all nodes beneath the parent  or null
  parentNode      => each child has a parent node property that points back to the parent     or null 
  firstChild      => equivelent to childNodes[0]                                              or null
  lastChild       => equivelent to childNodes[childNodes.length -1]                           or null

  others
  nextSibling     => equivelent to childNodes[n+1]                                            or null 
  previousSibling => equivelent to childNodes[n-1]                                            or null 


  walk the dom

      generic recursive function 

        function recurseAndLog(array) {
          if (array.length > 0) {
            console.log(array[0]);
            recurseAndLog(array.slice(1));
          }
        }

    when walking the dom we use dom nodes instead of an array

      example:

        function walk(node) {
          console.log(node);
          if (node.nextSibling) {
            walk(node.nextSibling);
          }
        }

        walk(document.body.firstChild);


      example: similar to forEach()

        function walk(node, callback) {                      // walk() calls the callback once for each node
          callback(node);                                    // do something with node

          for (var i = 0; i < node.childNodes.length; i++) { // for each child node
            walk(node.childNodes[i], callback);              // recursively call walk()
          }
        }                                                   

        walk(document.body, function(node) {                 // log the nodeName of every node
          console.log(node.nodeName);
        });


        this allows you to preform operations like the following
          var words = [];

          walk(document, function(node) {
            if (node.nodeName === "P") {
              var text = node.firstChild.data.trim();
              var firstWord = text.split(" ")[0];
              words.push(firstWord);
            }
          });

          console.log(words);  // ["A", "The", "The", "Where", "And"] 
 
 

*************************************************************************
*element attributes

  getting and setting attributes

    var p = document.querySelector('p');
    p                                      // <p class="intro" id="simple">...</p>
    p.hasAttribute('id')                   // true
    p.getAttribute('id')                   // 'simple'
    p.setAttribute('id', 'complex');     
    p                                      // <p class="intro" id="complex">...</p>

  attribute properties

    javaScript exposes the following attributes of the DOM property 
      id, name, title, value

      var p = document.querySelector('p');
      p                 // <p class="intro" id="simple">...</p>
      p.id              // 'simple'
      p.className       // 'intro'    (class is a reserved name in javaScript so use className instead)

      p.name            // undefined  (usually invalid)    
      p.title           // undefined 
      p.value           // undefined  (usually invalid)

      p.id = 'complex'  
      p.id              // 'complex'
      p                 // <p class="intro" id="complex">...</p>
    

  working with classLists
    p                  // <p class="intro" id="simple">...</p>
    p.className        // 'intro'
    p.classList        // ['intro'] returns an Array-like domTokenList object, usefull if there are multple classes
    
      the following functions work on a domTokenList object
        add(name)      // adds a new name to classList
        remove(name)   // removes an existing name from classList
        toggle(name)   // if the name exists removes it from classList and returns false (current status of the name
                          if the name doesn't exist adds it to classList and returns true
        contains(name) // returns if the name is in the classList
        length         // returns the length of the class list

  style
    you can also access and change style properties on an element
    style is not usually used, more common is toggling, adding or removing access to css properties

    p.style              // {alignContent: "", alignItems: "", alignSelf: "", alignmentBaseline: "", all: ""…}
                         // this actually returns all of the possible style properties as empty
    p.style.background   // ''
    p.style.background = 'green'  (the dom is updated and the screen show a green <p> background)
    p.style.background = null

    h1.style.lineHeight = '90px'  (camel case must be used for css hyphend properties)


**************************************************************************
*selecting elements

  document.querySelector()                      // select first element in the document by name
  document.querySelectorAll()                   // select all elements in the document by name

  document.getElementsByClassName('<selector>') // select all elements by class name
  document.getElementsByTagName('<selector>')   // returns all elements by tag name

  document.getElementById('<selector>')         // not plural becuase there should only be one id element

    with querySelectoryAll() you can select elements using the same selector pattern rules as css 
      querySelectorAll('div p.intro')          // selects all paragraphs with .intro class name inside a div 

    all of the dom selectors that can fetch multiple elements return array like structures
      but you should use a for loop to iterate overthem because forEach is not compatable with all browsers
      or make convert to an array
        var newArr = Array.prototype.slice.call(querySelectorResult);


  childElements (excludestext text nodes)
  body.children                             // returns all elements within the parent element
  body.children.length                      // returns element count 
  body.firstElementChild                    // returns first child element
  body.lastElementChild                     // returns last child element
  body.children[0].nextElementSibling       // returns next element sibling (previousNode.children[n + 1]) 
  body.children[0].lastElementSibling       // returns last element sibling (previousNode.children[n - 1]) 

  body.querySelector().textContent          // returns the text inside the selected elements 
                                            // .textContent does not work on querySelectorAll()
  body.querySelector().textContent = 'new text' // allows you to reassign text inside an element but 
                                            // replaces all text content in the element so if there is multple
                                            // lines of content select with span id and reasign by id



**************************************************************************
*creating adding and moving dom nodes

  
  p1 = document.createElement('p')            // creates an element by tag type (must be created on the document)
                                              // "[object HTMLParagraphElement]"
  t1 = document.createTextNode('sample text') // creates a text node (must be created on the document)
                                              // "[object Text]"
  p1.appendChild(t1);                         // <p>sample text</p>

  s2 = document.createElement('span')
  s2.textContent = 'span text'                // alternate way to append text to an element

  it is necessary to clone nodes because simply copying without cloneNode() it will still reference the orignal node
    if place a shallow copy on the page in a different place the original node will disapear
    true is the same as .cloneNode(deepClone)

    p2 = p1.cloneNode(true)                   // create a copy of an element with cloneNode(true)

  document.body.appendChild(p1)               // append to an element (body)

  You can't call document.appendChild; it causes an error. Use document.body.appendChild instead.

    

**************************************************************************
  // event-driven and asynchronous programing
**************************************************************************
*synchronous and asynchronous (asynchronous gotcha)

  synchronous code 
    runs sequentially(in order) fron top to bottom one line after the other
    the code never stops running until it is complete

  asynchronous code 
    does not run sequentially, part might run now, part might run later
    uses callback functions to run code later
    sometimes the call stack is not running any code while it is waiting for a callback

  virtual machine (processes callback requests)
    code is sent from the call stack to the virtual machine, once complete it is sent to the callback que

  event loop 
    continuously checks for code in the callback que and passes callbacks to the call stack

  
  **************************************************************************
  setTimeout(function(){}, 1000);                  // executes once after one second

  var intId = setInterval(function(){}, 1000);     // executes ever second until clearInterval is called on its id
  clearInterval(intId); 
  **************************************************************************


  example: asynchronous function 

    function makeLogger(i, message) {          
      return function() {
        console.log(i + ' ' + message);       // returns a function combining the interval and message  
      }
    }

    function delay(intervals, message) {
      for (var i = 1; i <= intervals; i++) {
        logger = makeLogger(i, message);      // sends a request for a function from make logger
        setTimeout(logger, i * 1000);         // setTimout gets passed to the virtual machine
      }                                       // the call stack moves onto the next for loop iteration 
    }

    delay(5, 'seconds later');
      // 1 seconds later
      // 2 seconds later
      // ...

  example: functions that register code in the virtual machine (to be called back later) 

    setTimeout(func, interval)                // time delay before running code

    var id = setInterval(func, interval);     // continuous loop of time delay before running code
      clearInterval(id)                       // the setInterval() loop must be cleared


  example: setInterval and clearInterval 

    function startCounting() {
      var count = 0;
      var id = setInterval(function() {
        console.log(count += 1);
        if (count > 3) stopCounting(id);
      }, 1000) 
    }

    function stopCounting(id) {
      clearInterval(id); 
    }

    startCounting();


  example : there is a common gotcha with creating closures with loops 

    the intention of following function is to log a number, once each second (up to max)
    
      function secondsLogger(max) {
        for (var i = 1; i < max; i++) {
          setInterval(function() {
            console.log(i);
          }, i * 1000);
        }
      }

      secondsLogger(10);

    instead of logging each number the number 10 is logged 10 times once each second
    this is because the setInterval is a closure and the lexical scope is set up
      when it is created, not when it is executed 
      (if var i changes the closure points to the changed i not the original var when the closure was created)
      i changes to 10 and the set interval closure reflects that change

      to remedy this you can move the setTimout closure to a seperate scope from the for loop

        function logger(val) {
          setTimeout(function() {
            console.log(val);
          }, val * 1000);
        }

        function secondsLogger(max) {
          for (var i = 1; i < max; i++) {
            logger(i);
          }
        }

        secondsLogger(10);

      or in es6 you can use let 
        let creates its own scope when the for loop is run

      function secondsLogger(max) {
        for (let i = 1; i < max; i++) {
          setInterval(function() {
            console.log(i);
          }, i * 1000);
        }
      }


**************************************************************************
*user interfaces and events

  an event is something that happends on the page
    they can be triggered by the following
      1. the browser  => example: when the document loads
      2. but the user => example: clicking on a button

    the web application interface handles two things
      1. displaying the user interface
      2. handleing events

    event listiner (aka event handler)
      the code that is run in response to an event firing
        event fires => code is run

    'DOMContentLoaded' => an argument for an event listener (executes when the dom has been constructed)
      happens after the html has been parsed and javaScript has been evaluated
      and before the page displays on the screen and embeded assets are loaded

      'load' is another argument (for an event handler) that executes after all 
        html, javascript and embeded assets have been loaded but is not usually very practical

    example: document loaded browser trigger

      document.addEventListener('DOMContentLoaded', function() {
        console.log('page loaded'); 
      });


**************************************************************************
*event handlers / listeners

  an event listener is a function that is called by the javaScript runtime when an event happens
    they require the following four steps

    1. identify the event (usually the event is triggered by the user or the page)
    2. identify the target element (where the function will be applied to)
    3. define the function (how will the target element be manipulated)
    4. register the function as an event listener

  global event handlers
    example :

    document.onclick = displayAlert
    document.onsubmit = somefunction
    document.onkeypress = somefunstion


    There are two ways to prevent an event handler from being run before the page has loaded
    both require wraping the event with DOMContenLoaded event listener

      1. Wrap a content loaded event listener around the event listener

        document.addEventListener('DOMContentLoaded', function() { 
          var button = document.getElementById('alert');                  
          button.addEventListener('click', displayAlert);                
        });

      2. set a global event handler  

        document.addEventListener('DOMContentLoaded', function() {        
          var button = document.getElementById('alert');                 
          button.onclick = displayAlert;
        });


  examples : 


    document.addEventListener('keypress', function(event) {
      document.body.textContent = `
        ${event.type}           // keypress
        ${event.currentTarget}  // [object HTMLDocument] 
        ${event.target}         // [object HTMLBodyElement]
        ${event.which}          // ASCII Key code
        ${event.shiftKey}       // boolean value (same with altKey, ctrlKey, metaKey)
      `;
    });

    keypress doesn't fire with certain events like backspace, alt, shift

    
    more properties of the event object for Mouse events

      clientX      // location of the mouse x axis
      clientY      // location of the mouse y axis


**************************************************************************
*event capturing and bubbling (event delegation)

  downsides to event handling 

    problem: 
      with event handleing it is sometimes impractical to place an event handler on every possible event
      you are also must wait until the DOMContentLoaded is complete
      if a new dom element is generated on the page later you have to remember to add an event handler to it 

    solution: event delegation (event capturing and bubbling)
      adding an event handler to a containing element that listens for events fired on all of it's children


  **************************************************************************
  event capturing and bubbling (event delegation)
    capturing     => the dom fires in succession moving inward
    target phase  => until it reaches its target
    bubbling      => and then moving outward
    
    capturing phase
    when you click on a nested element the dom fires an event an all of its parent elements starting with the window    
    target phase
    the event fired on the actual target

    bubbling phase
    then it turns around and fires an event on every single element in revers back to the window


  **************************************************************************
  capturing vs bubbling

    by default addEventListener() executes during the targed and bubbling phase

      document.addEventListener('click', function(event) {
        // listen for events during the targeting and bubbling phase
      });

    addEventListener() also takes a third optional argument this argument allows you to specify if 
    events should be fired during the bubbling phase(false is default) or catpturing phase(true)

     document.addEventListener('click', function(event) {
        // will listen for capturing events instaed of the default bubbling events
     }, true);    

    it is best practice to just use the default bubbling 


  **************************************************************************
  delegation

    one way to add event handlers to multiple elements

      addSelectorArr = querySelectorAll('.shared-class')

      for (var i = 0; i < addSelectorArr.length; i++) {
        addSelectorArr[i].addEventListener('click', function(event) {
          // do something with target
        }
      }
        
      however with this approach you have to wait until the dom is loaded to capture the arr of elements
        this can cause timing problems on a complex page
      if an additional element is added to the page later it will not be included in the for loop arr
        an additional event handler will have to be added


    using delegation (better)
    
      document.addEventListener('click', function(event) {
        var target = event.target;          // checks every possible target in the document
        if (target.tagName === 'BUTTON') {  // if the target meets the specification an event is preformed
          // do someting with target
        }
      }

      allows you to add an event handler to the entire document
      then check the tag name before applying the event

      delegation can also be added to parent elements insead of the entire document 
        if we only need to listen to elements that are children of the parent

      the tradeoff with event delegation is that sometimes it causes a lot of if else statements in the code
        this can become a problem in complex applications

      general rule is to start out binding elements individually and then as the code grows find areas where
        it is better to use event delegation
    

  **************************************************************************
  stop propagation

    allows you to apply an event handler to multple elements but only fires the event that the user interacts with
    it is best to place stopPropagation() or the following event.preventDefault() in the beginning of the code
      which makes it easier to debug if there are errors and makes the code more explicit and easier to understand

    example :

      function turnRed(event) {
        event.stopPropagation();
        event.currentTarget.style.background = 'red';
      }

      document.addEventListener('DOMContentLoaded', function() {
        document.querySelector('.outer').addEventListener('click',  turnRed);    
        document.querySelector('.inner').addEventListener('click',  turnRed);
      }); 

    in this example only the first clicked box will turn red instead of both


  **************************************************************************
  prevent default

    allows you to specify an alternate event than the default

    example :

    <a href="/">View page</a>

    document.addEventListener('DOMContentLoaded', function() {
      document.querySelector('a').addEventListener('click', function(event) {
        event.preventDefault();
        alert('Following the link was prevented.');
      });
    })

    this example give a pop up window instead of following the link

   
